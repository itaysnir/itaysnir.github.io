---
layout: post
title:  "KDLP - Part 0"
date:   2024-06-28 19:59:45 +0300
categories: jekyll update
---

**Contents**
* TOC
{:toc}
## Overview

Based on [kernel-development-learning-pipeline][kernel-development-learning-pipeline]. In particular, I'm following the course as it is given within spring 2024, where the course uses a Fedora-40 Linux distribution.

## Lecture 1

Simply an intro & guidelines. 

## Lecture 2 

Mailing list & git patches explanation. TODO: write more about this

## Lecture 3

### Build System

The kernel build system, `kbuild`. \
`Kconfig` is kind of its own PL, defines what is compiled into the kernel, whats compiled as a separate module, or not compiled at all. \
The `Kconfig` file at `src/linux` simply `source`s all of the `Kconfig` of the various subsystems. \
For example, `mm/Kconfig` describes the various of `CONFIG_*` options for that subsystem.

In order to compile the kernel via its makefile (using `make`), a `.config` file must exists. \
Some distributions, such as Fedora, exports the used `.config` file to build the system within the `/boot` directory, next to the kernel and initramfs. \ 
The kernel can be built via `make -j n`.

When creating a new driver, we can create a new config option by adding the following to its makefile:

```bash
obj-$(CONFIG_NAMEXXX) += driver.o
```

Some kernels adds a way to pull the `.config` file out of an existing `vmlinuz` image, by exporting a special file within `/proc/config.gz` (`CONFIG_IKCONFIG` should be enabled).

### Launch

We can test our created kernel via qemu. \
For example, within arm64:

```bash
qemu-system-aarch64 -machine virt -smp 1 -m 1024 -cpu cortex-a53 -kernel path-to-arm64-bzimage -display none -serial stdio -append "console=ttyAMA0"
```

Where: \
`-machine` - machine type (I've chose the default ARM VM). For x86, we can also state `ubuntu` \ 
`-smp` - number of CPUs. Notice we can also limit number of sockets, cores per socket, threads per core, and more \
`-m` - guest RAM \
`-cpu` - CPU which we would like to emulate \
`-kernel` - path to kernel image \
`-display` - display option, none means no display \
`-serial` - redirects serial port stdin, stdout to our chosen character device. In this case, `stdio`. \
`-append` - adds kernel command line argument, this time to add functionality to the console. 

By making the above command, the kernel boot should fail, stating it cannot mount root FS. \
Hence, we need some basic FS. \
Both `initrd` and `initramfs` (newer) serves as an in-RAM disk, providing initial functionality for the system before it loads the main disk FS. The difference between them, is that while `initrd` is actually a small implemented FS, `initramfs` are hierarchical files, compressed into `tmpfs` - a new FS of its own. Therefore, while `initrd` requires certain drivers to tell how to load its FS, `initramfs` do not - as it uses a default minimal `tmpfs`. \
We should generate `initramfs` file corresponding to our kernel, and store it under `/boot`. \
We can create it manually. For example, by simply creating an `init.S` program, that solely calls `exit()` (via `as, ld`). \
To make it compatible for qemu, we have to compress the created `init` binary via `cpio -co`, and supply it with the flag of `-initrd` (which is also given for `initramfs`). By doing so, the init userspace process would be running the `init` binary, and attempted to be terminated right away - as it executes our provided `initrd` file, which is a simple program that kills itself (while the `init` process actually invokes it). Hence, the kernel would panic as an attempt of killing `init` has been made. \
Notice we can also call the `reboot` syscall instead of `exit_group`. 

Infact, each distribution uniquely implements its own initramfs. \
To create a correct disk file, we have to provide basic linux functionality, and eventually spawn a shell within `init.S`. 

A fun fact to note, is that modern systems use `systemd` instead of `init` as pid `1`. 

## Lecture 4

The idea of this lecture is to actually implement our own `init.S` file, that would give us `busybox` functionality, and allow us to run a "hello-world" program. This init file would run busybox. \
Notice we would compile `busybox` statically, as we dont have a linker at this point. \
Next, we would upload a `cc` compiler, along with C-library `libc` to the root FS. 

### Busybox

In order to add busybox, we have to compile it statically ourselves. We can set this up via busybox's `.config` file.

In a similar manner, we've made a `busybox.cpio` by compressing the busybox binary via `cpio -cu`. \
We shall create the following hierarchy within `rootfs` (that would serve as the initramfs):

```bash
mkdir rootfs
mv busybox rootfs
```

And generate `init` binary within `rootfs`, that would simply `exec /busybox ash`. Notice it uses `#!/busybox/ash` as interpreter shell, which we should have due to `busybox` resides within the initramfs.

A cool trick we can do - instead of calling `/busybox ls`, a cool trick we can do is to create a symlink, `ln -s /busybox /bin/ls`. That way, every time we would type `ls`, it would trigger `busybox` with `ls` being its `argv[0]`, thus actually executing `busybox ls`. \
Apparently busybox's `make menuconfig` contains an option to install the applets as symlinks automatically for us. We have to run `make install` in order for these to apply, which would generate an `_install` directory. 

### tcc

Tiny version of `gcc`. We would compile `tcc` initially as a static binary, but eventually as a dynamic binary, as we would use dynamic linker later on. \
We copy the generated compilation targets to `/rootfs/lib/tcc/`, as well as `/rootfs/lib/libtcc.a`, `/rootfs/include/libtcc.h`.


### glibc

We would use it as our C library. \
After compilation, we shall issue `make install` and `make install-headers`, to store the desired targets into `rootfs`. \
Indeed, we can see it contains the various headers and object files of glibc components.

Notice glibc also contains the dynamic linker, under `/lib/ld-linux.so`.

### Compilation

Now we can perform compilation within the VM! Notice we would have to support `tcc` any library header paths or library binaries:

```bash
tcc hello.c -o hello -I/lib/tcc/include -L/lib/tcc
# OR:
export CPATH="/lib/tcc/inlude"
export LIBRARY_PATH="/lib/tcc"
```

Interesting to know, that during dynamic linking, the symbol `_start` is actually provided by issuing `-l:ctrl.o`, which is the object file corresponds to providing that symbol (not part of `libc`, as `-lc` won't provide the symbol).

### Procfs

In order to support utilities such as `ps`, we shall take advantage of filesystems that are exported by the kernel. In particular, we shall mount `/proc`. \
Hence, the following lines were added to the `init` script:

```bash
mkdir /proc
mount none /proc -t proc
```

Since this filesystem isn't backed by any device on the disk, we shall state `none` as its device path. Another option is to state `proc` instead. \
After executing these commands, we can see the `/proc` directory contains the expected procfs content.

### Sysfs

Contains information about the system, devices, etc. This filesystem exports kernel objects. \
We can mount it in a similar manner to `procfs`:

```bash
mkdir /sys
mount none /sys -t sysfs
```

### Funky C Preprocessor

We can define functions by macros using token concatenation via `##`:

```c
#define ATOMIC_OP(op)							\
static __always_inline void arch_##op(int i, atomic_t *v)		\
{									\
	__lse_ll_sc_body(op, i, v);					\
}

ATOMIC_OP(atomic_andnot)
ATOMIC_OP(atomic_or)
```

As well as to concat two string literals by simply declaring them in an adjacent manner.

```c
const char *s1 = "hello" " " "world!";
// Equal to:
const char *s2 = "hello world!";
```

Moreover, we can replace a macro parameter with a string of the actual argument via `#`:

```c
#define WARN_IF(EXP) \
     do { if (EXP) \
             fprintf (stderr, "Warning: " #EXP "\n"); } \
     while (0)

WARN_IF(x == 0);
    ==> do { if (x == 0)
        fprintf (stderr, "Warning: " "x == 0" "\n"); } while (0);
```

### Cool Kernel Macros

There are many `*for_each*` macros, such as `for_each_prime_number` and `list_for_each`.

There are also gcc-specific tweaks we can do: [statement-exprs][statement-exprs].

### Assembly Macros

Denoted via `.macro` within the `asm.S` file (capital `.S` denotes an assembly file that have to be pre-processed). \
Can be used in addition to C-macros.


## Setup



## E0

## P0

Implemented a decent unix shell, can be found [here][kdlp-p0]. 





[kernel-development-learning-pipeline]: https://kdlp.underground.software/index.html
[kdlp-p0]: https://github.com/itaysnir/KDLP-P0
[statement-exprs]: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html
