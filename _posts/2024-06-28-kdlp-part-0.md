---
layout: post
title:  "KDLP - Part 0"
date:   2024-06-28 19:59:45 +0300
categories: jekyll update
---

**Contents**
* TOC
{:toc}
## Overview

Based on [kernel-development-learning-pipeline][kernel-development-learning-pipeline]. In particular, I'm following the course as it is given within spring 2024, where the course uses a Fedora-40 Linux distribution.

## Lecture 1

Simply an intro & guidelines. 

## Lecture 2 

Mailing list & git patches explanation. TODO: write more about this

## Lecture 3

### Build System

The kernel build system, `kbuild`. \
`Kconfig` is kind of its own PL, defines what is compiled into the kernel, whats compiled as a separate module, or not compiled at all. \
The `Kconfig` file at `src/linux` simply `source`s all of the `Kconfig` of the various subsystems. \
For example, `mm/Kconfig` describes the various of `CONFIG_*` options for that subsystem.

In order to compile the kernel via its makefile (using `make`), a `.config` file must exists. \
Some distributions, such as Fedora, exports the used `.config` file to build the system within the `/boot` directory, next to the kernel and initramfs. \ 
The kernel can be built via `make -j n`.

When creating a new driver, we can create a new config option by adding the following to its makefile:

```bash
obj-$(CONFIG_NAMEXXX) += driver.o
```

Some kernels adds a way to pull the `.config` file out of an existing `vmlinuz` image, by exporting a special file within `/proc/config.gz` (`CONFIG_IKCONFIG` should be enabled).

### Launch

We can test our created kernel via qemu. \
For example, within arm64:

```bash
qemu-system-aarch64 -machine virt -smp 1 -m 1024 -cpu cortex-a53 -kernel path-to-arm64-bzimage -display none -serial stdio -append "console=ttyAMA0"
```

Where: \
`-machine` - machine type (I've chose the default ARM VM). For x86, we can also state `ubuntu` \ 
`-smp` - number of CPUs. Notice we can also limit number of sockets, cores per socket, threads per core, and more \
`-m` - guest RAM \
`-cpu` - CPU which we would like to emulate \
`-kernel` - path to kernel image \
`-display` - display option, none means no display \
`-serial` - redirects serial port stdin, stdout to our chosen character device. In this case, `stdio`. \
`-append` - adds kernel command line argument, this time to add functionality to the console. 

By making the above command, the kernel boot should fail, stating it cannot mount root FS. \
Hence, we need some basic FS. \
Both `initrd` and `initramfs` (newer) serves as an in-RAM disk, providing initial functionality for the system before it loads the main disk FS. The difference between them, is that while `initrd` is actually a small implemented FS, `initramfs` are hierarchical files, compressed into `tmpfs` - a new FS of its own. Therefore, while `initrd` requires certain drivers to tell how to load its FS, `initramfs` do not - as it uses a default minimal `tmpfs`. \
We should generate `initramfs` file corresponding to our kernel, and store it under `/boot`. \
We can create it manually. For example, by simply creating an `init.S` program, that solely calls `exit()` (via `as, ld`). \
To make it compatible for qemu, we have to compress the created `init` binary via `cpio -co`, and supply it with the flag of `-initrd` (which is also given for `initramfs`). By doing so, the init userspace process would be running the `init` binary, and attempted to be terminated right away - as it executes our provided `initrd` file, which is a simple program that kills itself (while the `init` process actually invokes it). Hence, the kernel would panic as an attempt of killing `init` has been made. \
Notice we can also call the `reboot` syscall instead of `exit_group`. 

Infact, each distribution uniquely implements its own initramfs. \
To create a correct disk file, we have to provide basic linux functionality, and eventually spawn a shell within `init.S`. 

A fun fact to note, is that modern systems use `systemd` instead of `init` as pid `1`. 

## Lecture 4

The idea of this lecture is to actually implement our own `init.S` file, that would give us `busybox` functionality, and allow us to run a "hello-world" program. This init file would run busybox. \
Notice we would compile `busybox` statically, as we dont have a linker at this point. \
Next, we would upload a `cc` compiler, along with C-library `libc` to the root FS. 

### Busybox

In order to add busybox, we have to compile it statically ourselves. We can set this up via busybox's `.config` file.

In a similar manner, we've made a `busybox.cpio` by compressing the busybox binary via `cpio -cu`. \
We shall create the following hierarchy within `rootfs` (that would serve as the initramfs):

```bash
mkdir rootfs
mv busybox rootfs
```

And generate `init` binary within `rootfs`, that would simply `exec /busybox ash`. Notice it uses `#!/busybox/ash` as interpreter shell, which we should have due to `busybox` resides within the initramfs.

A cool trick we can do - instead of calling `/busybox ls`, a cool trick we can do is to create a symlink, `ln -s /busybox /bin/ls`. That way, every time we would type `ls`, it would trigger `busybox` with `ls` being its `argv[0]`, thus actually executing `busybox ls`. \
Apparently busybox's `make menuconfig` contains an option to install the applets as symlinks automatically for us. We have to run `make install` in order for these to apply, which would generate an `_install` directory. 

### tcc

Tiny C compiler. Tiny version of `gcc`. \
We compile `tcc` as a static binary, both C compiler and loader. 

1:27









## Setup



## E0

## P0

Implemented a decent unix shell, can be found [here][kdlp-p0]. 





[kernel-development-learning-pipeline]: https://kdlp.underground.software/index.html
[kdlp-p0]: https://github.com/itaysnir/KDLP-P0
