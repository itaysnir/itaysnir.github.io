---
layout: post
title:  "KDLP - Part 2"
date:   2024-07-01 19:59:45 +0300
categories: jekyll update
---

**Contents**
* TOC
{:toc}
## Lecture 13

Covers character devices - motivation, interaction, implementation.

### Chardevs

Character-by-character kernel interface. Meaning a byte-stream, not buffered, input. For example, keyboard, mouse. But it isn't necessarily related to physical device. \
Character devices can be found under `/dev`, having `c` as file type. Uniquely identified by major (type / category identifier), minor (instance identifier) numbers. Generally, implemented as a kernel module. We can create character (unbuffered) / block (buffered) manually devices via `mknod`. \
Another interesting file is `/proc/devices`, which contains the major to device type mapping. 

### Interaction

Everything is a file. Hence, simple `cat, echo` commands works on the device files. Also syscalls involving fds. 

### Examples

Some useful devices:

```bash
/dev/null  # discard input
/dev/zero  # infinite number of b'\x00' output
/dev/tty   # this terminal, equivalent of R/W from stdin/stdout
/dev/kmsg  # kernel ring buffer access, dmesg parses this
/dev/urandom  # infinite random bytes, crypto-secured
/dev/random  # same, but can block in case system's entropy is low (for example, shortly after boot)
/dev/mem  # Physical memory access!
```

### PRNG Chardev Impl

Demonstration of a basic character device kernel module. We have to perform few steps:

1. Assign major, minor numbers

2. Set file operations - `fops`, that stores addresses of the handlers. 

3. Register device with cdev subsystem

4. Implement handlers for `open, close`

5. Implement handlers for `read, write`

Note: `__init` is a special section of the object, that contains the init functions. It can be reclaimed after module load. 

```c
#include <linux/module.h>
#include <linux/errname.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/kdev_t.h>


dev_t major_minor;
size_t minor_count = 10;
struct cdev kdlpdev;

int kdlp_open(struct inode * inode, struct file * file) {
    file->private_data = (void *) 0x4141414142424242;
    return 0;
}

int kdlp_close(struct inode * inode, struct file * file) {
    return 0;
}

ssize_t kdlp_read(struct file * file, char * __user buf, size_t count, loff_t * fpos) {

}

ssize_t kdlp_write(struct file * file, const char * __user buf, size_t count, loff_t * fpos) {
    pr_info("write %d:%d\n", imajor(file->f_inode), iminor(file->f_inode));
    return -EFAULT;
}

struct file_operations fops = {
    .owner = THIS_MODULE,
    .open = kdlp_open,
    .release = kdlp_close,
}

int __init kdlpdev_init(void)
{
    int ret = alloc_chrdev_region(&major_minor, 0, minor_count, "kdlpdev");
    if (ret < 0)
    {
        pr_err("major/minor allocation failure: %d(%s)\n", ret, errname(ret));
    }

    char buf[64];
    pr_info("major:minor = %s\n", format_dev_t(buf, major_minor));

    cdev_init(&kdlpdev, &fops);
    cdev_add(&kdlpdev, major_minor, 1);

    return 0;
}

void kdlp_cleanup(void)
{
    unregister_chrdev_region(major_minor, minor_count);
    cdev_del(&kdlpdev);
}

module_init(kdlpdev_init);
module_exit(kdlpdev_exit);
MODULE_LICENSE("GPL");
```

The major and minor are contained in `dev_t` type, where the CTOR is `MKDEV`, and the getters are `MAJOR, MINOR`. \
We can dynamically allocate the major, minor numbers using `alloc_chrdev_region`, which internally calls `MKDEV`. The static version is `register_chrdev_region`, but it isn't frequently used as collisions between drivers may occur. 

### Necessary Symbols

`struct cdev` - contains the `dev_t`, module owner, `fops` and linked list (for all minors within starting from `dev_t`) and its count, as well as `kobject` for refcounting. 

`struct file_operations` - the function pointers associated with the device. 

`cdev_init` - initializes `cdev`, associates it with a `fops`. 

`cdev_add` - actually adds the `cdev` to the system. It does so by registering the device to the `cdev_map`. 

### Open, Close

`struct inode` - represent information about a file, within certain device, which is represented by the `i_rdev` member. 

`struct file` - encapsulates `struct inode`, and stuff related to the file layer, such as path. 

### Read, Write

We'd use the helper functions `copy_to{from}_user`. Notice the `__user` macro is a syntatic macro, that has no actual runtime effect. \
Notice that EOF is signalled by returning a `0` from the read handler. This can be done, in case `*fpos` passes certain value. 

### Notes

1. Even after unloading the module, and calling the destructor methods, a `kdlpdev` would reside on the non-procfs filesystem. This reference is invalid, and upon performing operations on it - would cause an error. 

2. `file->private_data` usually contains a pointer to a driver-defined struct, which encapsulates the driver's-specific needed datum.

3. Recall we've created devices using `mknod`. Another option is automatic - 

## Lecture 14

### Synchronizing the CPU

The `jiffies` counts CPU timer interrupts since boot, allows calculating time between in-kernel events. The `HZ` kernel config value contains the timer frequency - interrupts per second. 

### Grouping Devices

Each device class groups devices of similar type, defined within `struct class`. By using `class_create`, the desired class would be created under `/sys/class/`. \
As mentioned, device instances can be created manually. We can also instantiate these via device class. While device instance (created by `device_register`) is identified by major/minor pair, device class is identified by name string (creates devices via `device_create`). Both provides sysfs interface. 

### kkey

Kernel keyboard implementation, under `/dev/kkey{0 ... 127}`. We'd interpret the input bytes as MIDI audio bytes, which encodes musical information in events (not stream of audio). \
The driver implementation is as follows:

1. `sys_write` sends either `0` (up) or `1` (down) to one of the 128 keyboard devices, representing different notes. 

2. The input is being interpreted and stored within the module's memory.

3. Upon performing `sys_read`, a valid MIDI file is generated out of the stored bytes, and the cache is cleared. 

The example can be found under `kkey.c`. 

## Lecture 15

### Sysfs - class files

`struct class_attribute` defines the R/W handlers for a class file. 

### Mutex 

We can initialize Mutex either static (`DEFINE_MUTEX`) or dynamically (`mutex_init`). \
In terms of locking, `mutex_lock` is an uninterruptible locking - which shall be used with caution. `mutex_trylock` returns immediately (non-blocking), and `mutex_lock_interruptible` is the general used, which is blocking and suitable for chardevs. Unlocking is done via `mutex_unlock`. \
Notice the locks usage is forbidden under certain contexts: interrupt handlers, and atomic contexts. For these, we'd have to use `spin_lock, spin_unlock`. For "maybe-atomic" contexts, we'd use `spin_lock_irqsave`. 

### Atomic Vars

Initialized with `atomic{,64}_t` and `ATOMIC_INIT`. \
Read with `atomic_read`, write with `atomic_set`. There are also types `atomic_long_t, atomic_ptr_t`. 

## Lecture 16



