---
layout: post
title:  "KDLP - Part 1"
date:   2024-06-30 19:59:45 +0300
categories: jekyll update
---

**Contents**
* TOC
{:toc}
## Lecture 6

This lecture deals with execution contexts, and syscalls internals in particular. \
For x86-32, the syscall request is being issued via `int 0x80`, hence involves dereference of `IDT[0x80]`. For x86-64, `syscall` is used. For arm64, `svc`. \
If we would issue `msr VBAR_EL1, x0` from userspace, the program shall crash with an "illegal instruction". `msr` reads from model-specific register, into the second operand, `x0` in this case. Indeed, `VBAR_EL1` serves as the specific reg - vector base address register, execution level 1. Hence, by trying to access a register that belongs to execution level 1 from userspace, the kernel terminates our process. 

### Execution Context

Just CPU registers state. Hence, context === all registers values. \
For example, `setjmp(3)` saves the current state of the program, while `longjmp(3)` restores it. \
Another example are usermode threads. Recall they share heap, code, data - while having their own stack and registers. 

### Kernelspace and userspace

The main difference is their privilege level. \
An important simplification - kernelspace execution context can be subdivided, to code that *runs on behalf of a particular userspace process*, or *code that runs on its own behalf* (for example, kthreads or interrupt handlers). \
Context switch is capture of the current CPU regs state, and load of the previously-saved CPU regs. \
Kernel context switch is just as a regular processes context switch, but also changes the privileges. 

### Re-entrancy



42:30



## E1

## P1
