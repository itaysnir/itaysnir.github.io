---
layout: post
title:  "Pwn College - Multithreaded Heap Exploitation"
date:   2024-05-21 19:59:45 +0300
categories: jekyll update
---

**Contents**
* TOC
{:toc}
## Overview

## Background

### Heap Information Disclosure Via Races

For a single-threaded application, in order to exploit the heap, for example using a tcache poisoning (overwriting freed chunk `next`), a tcache pointer leak was sufficient to resolve any heap address. \
However, for the multithreaded scenario, this is no longer the case. There are actually multiple heaps, one for every thread, each having its own associated arena. This means that **the leaks will be pointers to the specific thread's heap**. This means that the addresses received by `malloc` are different for every thread, even in case of the same ordering. \
The following POC demonstrates this:

```c
void *thread_main(void *x) {
    printf("%p\n", malloc(1024));
    pthread_exit(0);
}

int main(){
    printf("%p\n", malloc(1024));
    pthread_t t1, t2, t3;
    pthread_create(&t1, NULL, thread_main, NULL);
    pthread_create(&t2, NULL, thread_main, NULL);
    pthread_create(&t3, NULL, thread_main, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    pthread_join(t3, NULL);
}
```

Upon running this program, similar output would be printed:

```bash
0x4052a0
0x7ffff0000b70
0x7fffe8000b70
0x7fffe8000f80

pwndbg> arenas
arena type    arena address    heap address       map start         map end    perm    size    offset              file
--------------  ---------------  --------------  --------------  --------------  ------  ------  --------  ----------------
    main_arena   0x7ffff7faeac0        0x405000        0x405000        0x426000    rw-p   21000         0            [heap]
non-main arena   0x7fffe8000030  0x7fffe80008d0  0x7fffe8000000  0x7fffe8021000    rw-p   21000         0  [anon_7fffe8000]
non-main arena   0x7ffff0000030  0x7fffef8008d0  0x7fffef800000  0x7ffff0021000    rw-p  821000         0  [anon_7fffef800]
```

Indeed, we can see the main thread have performed allocations from its main heap, resulting in the "regular" address space we are familiar with of the heap. \
However, for non-main heaps, allocations were from different memory regions, right past the heap:

```bash
0x404000           0x405000 rw-p     1000   3000 /home/hacker/test                                                                                                                                                                                       
          0x405000           0x426000 rw-p    21000      0 [heap]                                                                                                                                                                                                  
    0x7fffe8000000     0x7fffe8021000 rw-p    21000      0 [anon_7fffe8000]
    0x7fffe8021000     0x7fffec000000 ---p  3fdf000      0 [anon_7fffe8021]
    0x7fffef7ff000     0x7fffef800000 ---p     1000      0 [anon_7fffef7ff]
    0x7fffef800000     0x7ffff0021000 rw-p   821000      0 [anon_7fffef800]                                                                                                                                                                                        
    0x7ffff0021000     0x7ffff4000000 ---p  3fdf000      0 [anon_7ffff0021]                                                                                                                                                                                        
    0x7ffff6da6000     0x7ffff6da7000 ---p     1000      0 [anon_7ffff6da6]                                                                                                                                                                                        
    0x7ffff6da7000     0x7ffff75a7000 rw-p   800000      0 [anon_7ffff6da7]
```

Interestingly, after every non-main heap pages, there is a large chunk of memory, in which the heap may expand to, in case it is needed. This is where the thread's stack is being allocated from. Also, this means that every thread for this libc version may have an heap + stack regions of up to `0x4000000` bytes. \
In addition, this region is mapped without any permission bits. This denotes that these pages are saved to be serving allocations requests, of either stack or the heap. Moreover, there are guard pages, right before every arena start. They defeat exploitation of linear heap overflows in case of crossing between thread's arenas. 

Notice another interesting behavior here - while 2 of the allocations had the exact same LSBs, which is expected as each thread have its own heap, the last one did not. \
In particular, it seems like its chunk was allocated from the previous thread's heap! This is due to the second thread terminating and reclaimed before the third thread, hence the second thread's heap was reused by the third. This is verified, as we can see only 2 non-main arenas were generated. 

In addition, for the main heap, we can see its arena resides **within a libc memory region**:

```bash
0x7ffff7fae000     0x7ffff7fb0000 rw-p     2000 1dd000 /nix/store/dbcw19dshdwnxdv5q2g6wldj6syyvq7l-glibc-2.39-52/lib/libc.so.6
```

This means that upon achieving a libc leak, we can navigate towards the arena address of the main heap! \
However, for all non-main heaps, their corresponding arenas were allocated within the start of the heap itself.  

#### MT Tricks

Recall `printf`. A naive implementation of it would be something as follows:

```c
int naive_printf(const char *str)
{
    int length = strlen(str);
    write(1, str, length);
}
```

However, in case there's no locking being used, this function is vulnerable to MT, as other thread-2 may shrunk `str`, right between thread-1 `length` calculation and its `write` to stdout. \
The interesting part is, **THAT IS THE IMPLEMENTATION OF PRINTF** (aside from parsing format string tokens..). This means that by simply having a MT program with a `printf` call of some memory address that is shared among threads, we can obtain leak (for example, if the other thread `free`s that address). \
Moreover, because `write` is a syscall while `strlen` is a library call, this race have good odds of winning!

### Memory Forensics

Notice that sometimes we would have a thread's arena leak, and we'd like a libc leak. \
While the `main_arena` resides within a constant offset within libc (hence resolving it would acquire us reliable libc leak), other arenas do not - as there are random amount of pages being allocated between libc mappings and the various arenas. \
However, usually that number of pages is very low (max 2 bytes) - and can be easily brute-forceable. 
This means that we can actually turn any thread's arena leak into a libc leak (which translates to stack leak via `environ`). 

In particular, notice that for memory regions allocated by `mmap`, there's usually some small amount of pages boundary in-between. These are all brute-force able relatively easily. 

### Arbitrary R / W

Some gotchas including a positive value for tcachebin `count`. In that case, allocations would be made, racing with our exploit. \
We like to make sure the `count` of the bin is set to `0` after we've allocated a chunk at the arbitrary address. That way, other `malloc` calls would be performed off completely different memory regions. \
Another way to bypass this, is to create a new thread for each attempt. Because the tcache is a per-thread resource, the tcache metadata would be re-initialized for each invocation. 

Another gotcha is not paying attention to any side effects caused by the R / W implementations. For example, if the arbitrary read imlementation internally `malloc`'s a target addres via tcache poisioning, it actually nullifies the second qword. 


