---
layout: post
title: "CVE-2017-11176 - Linux Kernel Exploitation"
date: 2025-04-30 21:59:45 +0300
categories: jekyll update
---

**Contents**
* TOC
{:toc}
## Introduction

I've wrote this document in order to gain a deeper understanding of kernel exploitation. \
While there's a reference exploitation for kernel `2.6.32` within the following [link][ref-link], my goal is to apply the exploit for kernel `3.16.36`. 

## Setup

### VM Setup

Kernel 3.16.36 ISO: 

```bash
wget https://cdimage.debian.org/mirror/cdimage/archive/8.6.0-live/amd64/iso-hybrid/debian-live-8.6.0-amd64-standard.iso
```

I've default-installed the ISO using VMWare, with 1 CPU (easier debugging), `1GB RAM`, enabled SMEP and disabled kASLR & SMAP. \
The default credential for Debian-live is `user:live`. \
I've also verified SMEP is enabled and SMAP disabled by reading `/proc/cpuinfo`. Original `/proc/cmdline`:

```bash
BOOT_IMAGE=/boot/vmlinuz-3.16.0-4-amd64 root=UUID=3575d19c-e12f-4279-a054-3fd133416578 ro initrd=/install/initrd.gz quiet
```

To disable KASLR, I've added the following to `/etc/default/grub`:

```bash
GRUB_CMDLINE_LINUX_DEFAULT="quiet nokaslr nosmap"
GRUB_CMDLINE_LINUX="initrd=/install/initrd.gz"
$ update-grub
```

Within the `/boot` directory, we can see the `initrd.img`, `vmlinuz`, as well as the kernel's config file. The used allocator is SLAB:

```bash
CONFIG_SLAB=y
# CONFIG_SLUB is not set
# CONFIG_SLOB is not set
```

Upon rebooting, `/proc/cmdline` had the extra entries of `nokaslr, nosmap`. 

### Packages

We can download manually the required debian packages for kernel debugging, from the [snapshot debian packages][deb-packages]. 

```bash
uname -v
#1 SMP Debian 3.16.36-1+deb8u1 (2016-09-03)
```

In particular, `linux-image-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb` contains the actual kernel binary and modules. This installs bootable kernel (vmlinuz), kernel modules under `/lib/modules/$(uname -r)`, and initrd image under `/boot`. This is the minimum required to run the desired kernel. \
`linux-image-3.16.0-4-amd64-dbg_3.16.36-1+deb8u1_amd64.deb` (debug) - contains debugging symbols for the kernel, with DWARF symbols - and would make our lives easier using GDB. It stores the unstripped `vmlinux` within `/usr/lib/debug/boot/$(uname -r)`. \
`linux-headers-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb` - the kernel headers, required for module development. \
`linux-source-3.16_3.16.36-1+deb8u1_all.deb` - kernel source code, installs them under `/usr/src`. 

```bash
wget --no-check-certificate https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-image-3.16.0-4-amd64_3.16.36-1%2Bdeb8u1_amd64.deb
wget --no-check-certificate https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-image-3.16.0-4-amd64-dbg_3.16.36-1%2Bdeb8u1_amd64.deb
wget --no-check-certificate https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-headers-3.16.0-4-amd64_3.16.36-1%2Bdeb8u1_amd64.deb
wget --no-check-certificate https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-source-3.16_3.16.36-1%2Bdeb8u1_all.deb

dpkg -i linux-image-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
dpkg -i linux-image-3.16.0-4-amd64-dbg_3.16.36-1+deb8u1_amd64.deb
dpkg -i linux-headers-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
dpkg -i linux-source-3.16_3.16.36-1+deb8u1_all.deb
```

To support regular APT packages installation, I've set the archive debian as the sources-list, and ignored expiration dates:

```bash
# Within /etc/apt/sources.list
deb http://archive.debian.org/debian jessie main contrib non-free
deb-src http://archive.debian.org/debian jessie main contrib non-free

echo 'Acquire::Check-Valid-Until "false";' | sudo tee /etc/apt/apt.conf.d/99no-check-valid-until
```

Now, I could install some required packages: 

```bash
apt-get install -y gcc gdb bear binutils make systemtap`
```

### Compilation

I've compiled the exploit without any optimizations, and as PIC:

```bash
gcc -fpic -O0 -std=c99 -Wall -pthread ...
```

### Source Code

I've first re-built the kernel sources with bear, generating `compile-commands.json`, for Clangd to work properly. I've also disabled Microsoft C/C++ plugin, as they usually interfere. 

```bash
cd linux-source-dir/
make clean
make defconfig
bear -- make -j$(nproc)
```

I've set samba on the VM such that I'd be able to navigate within the shared sources from my host Windows machine. \
This approach works pretty well on a Linux host machine, but for Windows the compile-commands paths differs, and even while stating `path-remaping` feature of clangd, it doesn't gets parsed properly. While I could edit the `compile_commands.json` file so it would match the windows paths, I preferred using the portable solution, using `cscope + ctags` on the Ubuntu VM, along with relevant plugins (ctags support, cscope-code):

```bash
cd linux-src/
find . -name "*.[ch]" > file_list

# Generate cscope index
cscope -b -q -k -i file_list

# Generate ctags
ctags -R --languages=C --fields=+iaS --extra=+q .
```

For VSCode to keep track of all files in the kernel source tree, I've tweaked the relevant inotify property:

```bash
sudo bash -c 'echo "fs.inotify.max_user_watches=524288" >> /etc/sysctl.conf'
sudo sysctl -p
```

I found the following `settings.json` ideal for kernel sources. Notice it disables c/c++ extension, as clangd takes place instead:

```bash
 {
        "files.exclude": {
            "**/.*.*.cmd": true,
            "**/.*.d": true,
            "**/.*.S": true,
            "**/.tmp*": true,
            "**/*.tmp": true,
            "**/*.o": true,
            "**/*.a": true,
            "**/*.builtin": true,
            "**/*.order": true,
            "**/*.orig": true,
            "**/*.symvers": true,
            "**/*.modinfo": true,
            "**/*.map": true,
            "*.cache/**": true
        },
	"search.exclude": {
   	 	"**/.*.cmd": true,
    		"**/.*.d": true,
    		"**/.*.S": true,
    		"**/.tmp*": true,
    		"**/*.tmp": true,
    		"**/*.o": true,
    		"**/*.a": true,
    		"**/*.builtin": true,
    		"**/*.order": true,
    		"**/*.orig": true,
    		"**/*.symvers": true,
    		"**/*.modinfo": true,
    		"**/*.map": true,
    		"*.cache/**": true
  	},
        "editor.detectIndentation": false,
        "editor.tabSize": 8,
        "editor.insertSpaces": false,
        "editor.rulers": [80,100],
        "files.associations": {
	"**/x86/**/*.S": "asm-intel-x86-generic",
    	"**/arch/x86/entry/calling.h": "asm-intel-x86-generic",
    	"**/arm64/**/*.S": "arm64",
    	"*_defconfig": "kconfig",
        "*.h": "c"
        },
	"git.alwaysSignOff": true,
	"C_Cpp.autocomplete": "disabled",
  	"C_Cpp.formatting": "disabled",
  	"C_Cpp.errorSquiggles": "disabled",
  	"C_Cpp.intelliSenseEngine": "disabled",
	"editor.renderWhitespace": "boundary",
	"gitlens.showWelcomeOnInstall": false,
  "gitlens.showWhatsNewAfterUpgrades": false,
  "gitlens.plusFeatures.enabled": false,
  "gitlens.mode.statusBar.enabled": false,
  "gitlens.statusBar.enabled": false,
  "gitlens.remotes": [
    {
      "regex": ".+:\\/\\/(git\\.kernel\\.org)\\/(.+)",
      "type": "Custom",
      "name": "kernel.org",
      "protocol": "https",
      "urls": {
        "repository": "https://git.kernel.org/${repoBase}/${repoPath}/tree",
        "branches": "https://git.kernel.org/${repoBase}/${repoPath}/refs",
        "branch": "https://git.kernel.org/${repoBase}/${repoPath}/log/?h=${branch}",
        "commit": "https://git.kernel.org/${repoBase}/${repoPath}/commit/?id=${id}",
        "file": "https://git.kernel.org/${repoBase}/${repoPath}/tree/${file}${line}",
        "fileInBranch": "https://git.kernel.org/${repoBase}/${repoPath}/tree/${file}?h=${branch}${line}",
        "fileInCommit": "https://git.kernel.org/${repoBase}/${repoPath}/tree/${file}?id=${id}${line}",
        "fileLine": "#n${line}",
        "fileRange": "#n${start}"
      }
    }
  ],
  "trailing-spaces.highlightCurrentLine": false,
  "trailing-spaces.deleteModifiedLinesOnly": true,
  "trailing-spaces.trimOnSave": true,
  "systemtap-assistant.deploy-task": "Build systemtap tracer",
  "debug.onTaskErrors": "debugAnyway"
    }
```

The following [repo][vscode-kernel] is very handy for configuration of Linux kernel sources.

### Run + Debug

[This repo][debug-kernel] is very convenient for kernel debugging with QEMU.

## Background

### Relevant Structs

For MT userland process, there's one `task_struct` for every thread. Kernel threads also have their own `task_struct`, which isn't mapped to any user VA space. \
Each open file is represented by `struct file`, which is stored within `struct fdtable`. Each `task_struct` contains a `files_struct` pointer to the corresponding `fdtable`. This pointer might be shared between multiple tasks for optimization reasons. \
`struct socket` contains special kind of function table - `struct proto_ops`, which every type of socket (either `AF_INET` or `AF_NETLINK`) must implement. This means taht upon invoking BSD-style syscall, the kernel first retrieves `struct file` from the FDT, retrieves `struct socket` from the `struct file`, and invokes the specialized `proto_ops` callback. The protocol-specific implementation of a socket is given by `struct sock`, and this `struct file` & `struct socket` polymorphism, allowing various of `struct sock` "subclasses" can be seen as follows: 

```c
struct socket {
    struct file     *file;
    struct sock     *sk;
    const struct proto_ops  *ops;
  // ...
};
```

`struct sock` is actually a very large struct, where the real magic of low-level networking operations (send, recv) occurs. It actually contains a generic implementation of holding the send/recv buffers. \
Whenever a packet is received, a driver enqueues the network packet into the `struct sock` receive buffer, which would stay there until the program decides to receive it via `recvmsg`. \
When a program sends data via `sendmsg`, it enqueues the network packet into the `struct sock` sending buffer. Upon notification, the network card driver dequeues that packet and sends it. \
Those network packets are `struct sk_buff`:

```c
struct sock {
    int         sk_rcvbuf;    // theorical "max" size of the receive buffer
    int         sk_sndbuf;    // theorical "max" size of the send buffer
    atomic_t        sk_rmem_alloc;  // "current" size of the receive buffer
    atomic_t        sk_wmem_alloc;  // "current" size of the send buffer
    struct sk_buff_head sk_receive_queue;   // head of doubly-linked list
    struct sk_buff_head sk_write_queue;     // head of doubly-linked list
    struct socket       *sk_socket;
  // ...
}
```

Netlink sockets allows user <-> kernel communication, as well as other processes communication. \
The relevant structs are `struct netlink_sock`, and `netlink_ops`:

```c
struct netlink_sock {
    /* struct sock has to be the first member of netlink_sock */
    struct sock     sk;
    u32         pid;
    u32         dst_pid;
    u32         dst_group;
  // ...
};

static const struct proto_ops netlink_ops = {
    .bind =     netlink_bind,
    .accept =   sock_no_accept,     // <--- calling accept() on netlink sockets leads to EOPNOTSUPP error
    .sendmsg =  netlink_sendmsg,
    .recvmsg =  netlink_recvmsg,
  // ...
}
```

Because `struct sock` is the first member of the netlink socket, it actually implements polymorphism - hence `free(&netlink_sock) === free(&netlink_sock.sk)`, meaning - freeing the `sock` object actually frees the whole netlink sock. \
Notice `struct socket` is dereferenced via `struct file->private_data`.

### Reference Counters

The main goal is to reduce leaks & prevent UAFs, using `atomic_t` integer. It is only manipulated via atomic operations, such as `atomic_inc, atomic_add, atomic_dec_and_test` (checks if it reached zero - and if so, we would probably like to free it). \
The refcounting is done manually, hence - it must be explicitly increased / decreased. \
If the refcount is decreased twice for some reason - UAF. If it is increased twice - mem leak, and via int-overflow it may also lead to UAF. \
The `kref, kobject` facilities provides a common interface to deal with the counters, yet they aren't systematically used. In our case:

```c
struct sock: sock_hold(), sock_put()
struct file: fget(), fput()
struct files_struct: get_files_struct(), put_files_struct()
```

## Bug Analysis

The public information states the bug involves `mq_notify` syscall. \
According to the `man`, it involves registration for async notification whenever a message is available. Its first parameter denotes an empty message queue descriptor, while the second parameter is a pointer to `sigevent` struct (which describes how notification is to be performed - do nothing, send signal to the calling process, generate a new thread). \
Only one process can be registered to receive notification from a message queue. \
Interestingly, if the second parameter is `NULL` and the current process is already registered to the message queue, it actually removes the registration (similar to `realloc(ptr, 0)` behavior). Hence, another process can register to this message queue. \
Moreover, if the message queue wasn't empty, notification would occur only after the queue is emptied and a new message arrives.\
Another interesting behavior is in case another process / thread waits to read message from the queue via `mq_receive`. If that's the case, any message notification registration is ignored, the message is first delivered to the requesting task and only then the message notification registration applies. \
Notice - the notification occurs only once, hence after the notification is delivered, the registration to the message queue is removed, and another process can register for that queue.

The following NOTE is very sus - *For `SIGEV_THREAD`, much of the implementation resides within the library, rather than the kernel. The implementation involves the use of a raw netlink(7) socket and creates a new thread for each notification that is delivered to the process*.

The CVE description: *Themq_notifyfunction in the Linux kernel through 4.11.9 does not setthe sock pointerto NULL upon entry into theretry logic. During a user-space close of aNetlink socket, it allows attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact (ring-0 take over?).* \
[patch][patch]

Meaning the problem is within the retry logic of that syscall, and involving wrong refcount handling - as the netlink socket can be closed by userspace.

The `mq_notify` syscall wraps `do_mq_notify`, which is the vulnerable function. \
In case a notification of `SIGEV_THREAD` is made, interesting logic occurs:

```c
if (notification->sigev_notify == SIGEV_THREAD) {
			/* Create and copy from user skb buffer for notification */
            sock = NULL;
    retry:
          filp = fget(notification.sigev_signo);
          if (!filp) {
            ret = -EBADF;
            goto out;
          }
          sock = netlink_getsockbyfilp(filp);
          fput(filp);
          if (IS_ERR(sock)) {
            ret = PTR_ERR(sock);
            sock = NULL;
            goto out;
          }

          timeo = MAX_SCHEDULE_TIMEOUT;
          ret = netlink_attachskb(sock, nc, &timeo, NULL);
          if (ret == 1)
            goto retry;
          if (ret) {
            sock = NULL;
            nc = NULL;
            goto out;
          }

    /* Regular path*/

    out:
        if (sock) {
          netlink_detachskb(sock, nc);
        } else if (nc) {
          dev_kfree_skb(nc);
        }
        return ret;
		}
```

The bug is pretty clear - in case of an error within `netlink_attachskb` with `ret == 1`, the `sock` is still initialized, and the `retry` label occurs again. In that case, if we would make the first `fget` call to fail, `sock` would remain initialized, and the `out` label would be issued. If right after we would reach the `netlink_detachskb` path we would close the netlink socket from userspace, double-free would occur:

```c
void netlink_detachskb(struct sock *sk, struct sk_buff *skb)
    {
      kfree_skb(skb);
      sock_put(sk);       // <----- here
    }

static inline void sock_put(struct sock *sk)
    {
      if (atomic_dec_and_test(&sk->sk_refcnt))    // <----- here
        sk_free(sk);
    }
```

The `sock` object's refcount is incremented by `netlink_getsockbyfilp`, and decremented by `netlink_detachskb`. Interestingly, by reading `netlink_attachskb`, upon an error - a reference to the destination `struct sock` is dropped, **even in case of a retry**:

```c
    int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
              long *timeo, struct sock *ssk)
    {
      struct netlink_sock *nlk;
      nlk = nlk_sk(sk);
      if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) {
        // ... cut (wait until some conditions) ...
        sock_put(sk);         // <----- refcnt decremented here
        if (signal_pending(current)) {
          kfree_skb(skb);
          return sock_intr_errno(*timeo); // <----- "error" path
        }
        return 1;   // <----- "retry" path
      }
      skb_set_owner_r(skb, sk);   // <----- "normal" path
      return 0;
    }
```

Pretty amusing how `netlink_attachskb` has a side-effect of possibly decreasing the socket refcount. \

Vuln code path TL;DR:

1. Within `do_mq_notify`, set `notification->sigev_notify === SIGEV_THREAD` to reach the netlink socket logic

2. Get a valid `filp` reference for the provided userspace fd. Increment reference to its corresponding sock via `netlink_getsockbyfilp`, and decrease it back by triggering `netlink_attachskb` retry logic (message larger than `sk->sk_rcvbuf`). Notice how `sock` is still initialized, even after having a return value of `1` from the attach function.

3. Close the corresponding `filp` (netlink socket) from userspace. This requires winning a race.

4. The flow jumps back to the `retry` label, tries to get a `filp` reference and fails. Now the code jumps to the `out` label, while still having `sock` initialized.

5. `netlink_detachskb` is called on the `sock` address, eventhough it was already closed by userspace. Hence, obtaining double decrement of the reference of `sock`.

## Vuln Triggering

As mentioned, we have to provide notification of type `SIGEV_THREAD`. Also, because of a copy made within the kernel, we have to provide `notification.sigev_value.sival_ptr` to be a userspace address of at least `NOTIFY_COOKIE_LEN(32)` bytes, to serve as the `skb->data`.





[ref-link]: https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html
[deb-packages]: https://snapshot.debian.org/package/linux/3.16.36-1%2Bdeb8u1/
[vscode-kernel]: https://github.com/FlorentRevest/linux-kernel-vscode/tree/main
[debug-kernel]: https://github.com/gsingh93/linux-exploit-dev-env
[patch]: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f991af3daabaecff34684fd51fac80319d1baad1
